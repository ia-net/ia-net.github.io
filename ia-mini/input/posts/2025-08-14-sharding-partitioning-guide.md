---
Title: 대규모 데이터베이스 확장 전략 — 샤딩과 파티셔닝 완전 가이드
Published: 2025-08-14
Layout: /_layouts/post.cshtml
Excerpt: 수평 확장(샤딩)과 파티셔닝의 개념, 샤드 키 선택, 설계/운영 패턴, 리밸런싱, 트랜잭션/조인 대책
Tags: [database, scalability, sharding, partitioning]
---

## 목차

- [목차](#목차)
- [왜 확장이 필요한가](#왜-확장이-필요한가)
- [수직 확장 vs 수평 확장](#수직-확장-vs-수평-확장)
- [파티셔닝 vs 샤딩](#파티셔닝-vs-샤딩)
- [샤딩(수평 파티셔닝) 핵심 디자인](#샤딩수평-파티셔닝-핵심-디자인)
  - [샤드 키 선택 전략](#샤드-키-선택-전략)
  - [샤딩 방식: 범위 / 해시 / 디렉터리](#샤딩-방식-범위--해시--디렉터리)
  - [라우팅(샤드 맵) 패턴](#라우팅샤드-맵-패턴)
- [데이터 재분배(리밸런싱)](#데이터-재분배리밸런싱)
- [쿼리, 트랜잭션, 조인 다루기](#쿼리-트랜잭션-조인-다루기)
- [멀티테넌시와 격리](#멀티테넌시와-격리)
- [장애, 복구, 일관성](#장애-복구-일관성)
- [마이그레이션 절차(단계별 체크리스트)](#마이그레이션-절차단계별-체크리스트)
- [운영 팁 \& 모니터링 지표](#운영-팁--모니터링-지표)
- [샘플 스키마 \& 코드 스니펫](#샘플-스키마--코드-스니펫)
  - [샤드 맵 테이블(메타스토어)](#샤드-맵-테이블메타스토어)
  - [테넌트 디렉터리(예: 과열 테넌트 전용 라우팅)](#테넌트-디렉터리예-과열-테넌트-전용-라우팅)
  - [애플리케이션 라우팅(의사 코드)](#애플리케이션-라우팅의사-코드)
  - [팬아웃 리드(집계용)](#팬아웃-리드집계용)
- [요약](#요약)

---

## 왜 확장이 필요한가

- **사용자/트래픽 증가**: 단일 DB가 처리 가능한 IOPS/CPU/메모리를 초과.
- **데이터 폭증**: 저장/인덱스/백업·복구 시간이 기하급수로 늘어남.
- **SLA 요구**: 지연(latency) 상한선과 가용성 목표 달성 필요.

핵심은 **처리량을 늘리면서 지연을 낮추고, 가용성을 높이는 것**입니다.

## 수직 확장 vs 수평 확장

- **수직 확장(Scale-Up)**: 더 큰 머신으로 교체. 단순하지만 **상한선**이 분명하고 비용 기울기가 가팔람.
- **수평 확장(Scale-Out)**: 여러 노드로 분산. 운영 복잡도가 있지만 **선형에 가까운 확장성**을 얻을 수 있음.

> 일반적으로 읽기 부하는 **리드 레플리카**, 쓰기/저장 확장은 **샤딩**으로 해결합니다.

## 파티셔닝 vs 샤딩

- **파티셔닝(Partitioning)**: 하나의 논리 DB 안에서 테이블을 파티션으로 나눔. (DB 내부 기능)
- **샤딩(Sharding)**: **여러 DB 인스턴스**에 데이터를 나눠 저장하는 수평 파티셔닝. (애플리케이션/미들웨어 레벨 라우팅 필요)

둘은 보완 관계이며, **샤딩 후 각 샤드 내부에서도 파티셔닝**을 병행하기도 합니다.

## 샤딩(수평 파티셔닝) 핵심 디자인

### 샤드 키 선택 전략

샤드 키는 **데이터 분산 + 라우팅 효율 + 쿼리 패턴**을 동시에 만족해야 합니다.

좋은 샤드 키의 조건:
1. **높은 카디널리티**: 핫샤드(특정 샤드에 트래픽 집중) 방지.
2. **균등 분포**: 샤드 간 저장/트래픽이 고르게 분산.
3. **쿼리 경로와 정렬**: 가장 빈번한 조회/조인 조건에 잘 맞음.
4. **불변성**: 샤드 키 변경은 재분배 비용이 큼.

자주 쓰는 후보:
- 사용자 중심 서비스 → `UserId`
- B2B 멀티테넌시 → `TenantId`
- 로그/이벤트 → `Hash(EventSource or DeviceId)` + Time bucket

> **반드시 피할 것**: 단조 증가 키(예: `AUTO_INCREMENT`, 순증 타임스탬프)는 **한 샤드로 쓰기가 몰리는** 전형적 원인.

### 샤딩 방식: 범위 / 해시 / 디렉터리

1. **범위 샤딩(Range)**  
   - 예: `UserId 0~1M → Shard A`, `1M~2M → Shard B`  
   - 장점: **범위 스캔**과 정렬/페이징이 효율적.  
   - 단점: 키 분포가 치우치면 **핫스팟** 발생, 리밸런싱 시 범위 재조정 필요.

2. **해시 샤딩(Hash)**  
   - 예: `Shard = Hash(UserId) mod N`  
   - 장점: **균등 분산**에 강함, 핫샤드 위험 낮음.  
   - 단점: 범위 쿼리/정렬이 불리, 샤드 수 변경 시 **대규모 재해시** 필요.

3. **디렉터리(룩업) 샤딩(Directory/Lookup)**  
   - 중앙 **샤드 맵 테이블**에 `(Key → Shard)` 매핑 유지.  
   - 장점: **유연한 재배치** 가능(레코드/테넌트 단위 이동).  
   - 단점: 디렉터리의 **일관성/가용성**이 전체 시스템의 SPOF가 될 수 있음 → 캐시/레플리카/트랜잭션 관리 필요.

> 실무에서는 **해시 + 디렉터리**를 혼합해 *기본 균등 분산 + 예외(과열 테넌트) 수동 재배치*를 지원합니다.

### 라우팅(샤드 맵) 패턴

- **클라이언트 라우팅**: 앱이 샤드 맵을 캐싱해 직접 라우팅. 레이턴시 우수, 캐시 무효화 전략 필요.
- **미들웨어/프록시 라우팅**: 중간 계층이 라우팅 담당. 클라이언트 단순화, 중간층의 확장성/고가용성 설계 필요.
- **DB 라우터 내장형**: 일부 DB/서비스는 라우팅을 내장 제공(예: 특정 관리형 서비스, Vitess 등 개념). 운영 단순화.

샤드 맵은 다음 메타를 갖습니다:

| 컬럼 | 설명 |
|---|---|
| `ShardId` | 샤드 고유 식별자 |
| `KeyRange` 또는 `HashRange` | 담당 키 범위 |
| `Endpoint` | 연결 문자열/호스트 |
| `State` | Online/Draining/Rebalancing |
| `Version` | 맵 버전(원자적 교체/롤백용) |

## 데이터 재분배(리밸런싱)

언제 필요한가:
- 특정 샤드 **저장/트래픽 불균형**.
- 새로운 샤드 추가(스케일 아웃).
- 과열 테넌트 격리 필요.

전형적인 절차:
1. **플래닝**: 이동 대상(범위/테넌트) 선정, 목표 샤드 결정.
2. **드레이닝 상태** 전환: 쓰기 제한/라우팅 드레인 시작.
3. **증분 복제 + 컷오버**: 스냅샷 → 변경분 캡처(CDC) → 짧은 정지 구간으로 컷오버.
4. **검증**: 카운트/체크섬/샘플링 쿼리로 동등성 확인.
5. **맵 업데이트(원자적)**: `Version`을 증가시키며 교체.
6. **롤백 플랜**: 실패 시 역방향 컷오버.

> 체크포인트: **Dual-write**(양쪽에 동시 쓰기) 기간을 최소화하고, **Idempotent** 업서트로 재실행 안전성을 확보합니다.

## 쿼리, 트랜잭션, 조인 다루기

- **싱글 샤드 트랜잭션** 우선: 샤드 키를 쿼리 경로에 포함시켜 **로컬 트랜잭션**으로 끝내기.
- **크로스 샤드 쿼리**는 피하기: 불가피하면
  - **팬아웃 리드**(모든 샤드 병렬 조회 → 집계) + 타임아웃·부분 결과 허용
  - **사전 집계/머티리얼라이즈드 뷰**로 빈도를 낮춤
  - **샤드 간 2PC**는 가급적 회피(지연/가용성 리스크↑), 정말 필요하면 작고 드문 트랜잭션으로 제한
- **조인** 전략:
  - **공샤딩(Co-sharding)**: 자주 조인하는 테이블을 동일 키로 같은 샤드에 배치
  - **데이터 복제(Reference/Dimension Table)**: 작은 기준 테이블은 모든 샤드에 복제
  - **애플리케이션 레벨 조인**: 키 기반으로 개별 조회 후 앱에서 머지

## 멀티테넌시와 격리

- **공유 샤드(soft isolation)**: 테넌트를 같은 샤드에 함께 저장. 자원 효율 ↑, 간섭 위험 존재.
- **전용 샤드(hard isolation)**: 대형 테넌트는 전용 샤드로 분리. 성능 예측 가능, 운영비 ↑.
- **하이브리드**: 기본은 공유, 과열 테넌트만 디렉터리 샤딩으로 분리.

요구사항에 따라 **데이터 레지던시(지역/국가별)**와 **컴플라이언스**를 샤드 경계로 설계하기도 합니다.

## 장애, 복구, 일관성

- **레플리카**: 각 샤드마다 동기/비동기 복제 구성. RPO/RTO 목표와 쓰기 지연을 균형 있게 조정.
- **장애 전파 차단**: 샤드/프록시/클라이언트에 **회로 차단기 + 재시도 + 백오프**.
- **일관성 모델**: 강일관성(쓰기 지연↑) vs 최종일관성(성능↑). **도메인별로 선택**.
- **백업/복구**: 샤드 단위 스냅샷 + WAL/LSN 기반 시점 복구. **백업/복구 자동 검증** 필수.

## 마이그레이션 절차(단계별 체크리스트)

1. **워크로드 분석**
   - 상위 20% 쿼리/트랜잭션, 키 분포, 핫 테이블 파악.
2. **샤드 키/전략 결정**
   - (범위/해시/디렉터리) + 공샤딩 필요 여부.
3. **스키마/인덱스 설계**
   - 샤드 키 선행 컬럼, 보조 인덱스, 파티션 전략.
4. **샤드 맵/라우터 구현**
   - 캐시 전략(TTL/버전), 장애 시 폴백.
5. **데이터 이행 계획**
   - 스냅샷 → CDC → 컷오버. 리허설/리허설/리허설.
6. **관측성**
   - 샤드별 QPS, p95/p99, 에러율, 리드/라이트 분포, 리밸런싱 진행률.
7. **런북/롤백**
   - 장애 모드별 대응, 컷오버 실패 시 복귀 절차.

## 운영 팁 & 모니터링 지표

- **핫샤드 탐지**: 샤드별 QPS/IO/잠금 대기/큐 길이. 임계 초과 시 알람.
- **키 스큐 분석**: 상위 N 키/테넌트의 트래픽 점유율.
- **리밸런싱 헬스**: 이동량, 동기화 지연, 재시도율.
- **에러 버짓**: 크로스 샤드 쿼리 비율 상한 설정.
- **Capacity Plan**: 주 단위 성장률 기반 **90일** 선제 증설 계획.

## 샘플 스키마 & 코드 스니펫

> 예시는 **해시 + 디렉터리 샤딩** 혼합 패턴입니다.

### 샤드 맵 테이블(메타스토어)

```sql
CREATE TABLE ShardMap (
  ShardId       INT PRIMARY KEY,
  HashStart     INT NOT NULL,
  HashEnd       INT NOT NULL,
  Endpoint      VARCHAR(255) NOT NULL,   -- "Server=...;Database=Shard_12;..."
  State         VARCHAR(16) NOT NULL,    -- Online | Draining | Rebalancing
  Version       BIGINT NOT NULL
);

CREATE UNIQUE INDEX IX_Range ON ShardMap(HashStart, HashEnd);
```

### 테넌트 디렉터리(예: 과열 테넌트 전용 라우팅)

```sql
CREATE TABLE TenantDirectory (
  TenantId  BIGINT PRIMARY KEY,
  ShardId   INT NOT NULL,
  UpdatedAt DATETIME2 DEFAULT SYSUTCDATETIME()
);
```

### 애플리케이션 라우팅(의사 코드)

```csharp
// 1) 핫 테넌트는 디렉터리 우선
var shardId = dirCache.TryGetShard(tenantId)
           ?? Hash(tenantId) % shardCount;

var endpoint = shardMapCache.Resolve(shardId); // Versioned cache
using var conn = Open(endpoint);

// 2) 싱글 샤드 트랜잭션으로 처리
await using var tx = await conn.BeginTransactionAsync();
// ...
await tx.CommitAsync();
```

### 팬아웃 리드(집계용)

```pseudo
parallelFor shard in Shards:
    result[shard] = query(shard, "SELECT COUNT(*) FROM Orders WHERE CreatedAt >= @d")

return sum(result)
```

## 요약

- **샤드 키 선택**이 80%를 결정한다: **균등 분포 + 쿼리 경로 일치 + 불변성**.
- **해시/범위/디렉터리**를 도메인에 맞게 조합하고, **라우팅/샤드 맵**을 버전 관리하라.
- **리밸런싱 자동화**와 **관측성**이 장기 운영의 성패를 가른다.
- **크로스 샤드 트랜잭션/조인 최소화**가 성능과 단순성을 지킨다.
- 마이그레이션은 **스냅샷→CDC→컷오버**의 검증 가능한 파이프라인으로 구성할 것.